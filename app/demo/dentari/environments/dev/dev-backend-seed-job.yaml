---
apiVersion: batch/v1
kind: Job
metadata:
  name: dev-backend-seed
  namespace: dev-dentari
  labels:
    app: dev-backend-seed
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation,HookSucceeded
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        app: dev-backend-seed
    spec:
      restartPolicy: OnFailure
      imagePullSecrets:
        - name: ghcr-secret
      containers:
        - name: backend-seed
          image: ghcr.io/radamhu/dentari-backend:dev-2923b0c
          imagePullPolicy: Always
          env:
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: dev-dentari-secrets
                  key: db-password
            - name: DATABASE_URL
              value: "postgresql://dentari:$(DB_PASSWORD)@dev-db:5432/dentari"
            - name: SEED_DEMO_PASSWORD
              value: "DemoPassword123"
            - name: SEED_EMAIL_DOMAIN
              value: "dentari.local"
            - name: SEED_OWNER_USERNAME
              value: "owner"
            - name: SEED_OWNER_NAME
              value: "Demo Owner"
            - name: SEED_COURIER1_USERNAME
              value: "courier1"
            - name: SEED_COURIER1_NAME
              value: "Kovács János (Motor)"
            - name: SEED_COURIER2_USERNAME
              value: "courier2"
            - name: SEED_COURIER2_NAME
              value: "Nagy Péter (Autó)"
          command: ["/bin/bash", "-lc"]
          args:
            - |
              set -euo pipefail
              python <<'PYTHON_SEED'
              import os
              import sys
              import time
              from datetime import datetime

              import bcrypt
              from sqlalchemy import create_engine, text
              from sqlalchemy.orm import sessionmaker


              def hash_password(password: str) -> str:
                  return bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt()).decode("utf-8")


              db_url = os.getenv("DATABASE_URL")
              if not db_url:
                  print("❌ DATABASE_URL is required", file=sys.stderr)
                  sys.exit(1)

              max_retries = int(os.getenv("DB_MAX_RETRIES", "30"))
              retry_delay = float(os.getenv("DB_RETRY_DELAY", "2"))

              for attempt in range(1, max_retries + 1):
                  try:
                      engine = create_engine(db_url, pool_pre_ping=True)
                      with engine.connect() as conn:
                          conn.execute(text("SELECT 1"))
                      break
                  except Exception as exc:
                      if attempt == max_retries:
                          print(f"❌ PostgreSQL not ready after {max_retries} attempts: {exc}", file=sys.stderr)
                          sys.exit(1)
                      print(f"⏳ Waiting for PostgreSQL ({attempt}/{max_retries})...")
                      time.sleep(retry_delay)

              session = sessionmaker(bind=engine)()
              try:
                  table_exists = session.execute(
                      text(
                          """
                          SELECT EXISTS (
                              SELECT FROM information_schema.tables
                              WHERE table_schema = 'public'
                              AND table_name = 'users'
                          )
                          """
                      )
                  ).scalar()

                  if not table_exists:
                      print("❌ Users table does not exist. Run migrations first.", file=sys.stderr)
                      sys.exit(1)

                  user_count = session.execute(text("SELECT COUNT(*) FROM users")).scalar()
                  if user_count > 0:
                      print(f"✓ Database already has {user_count} users, skipping seed")
                      sys.exit(0)

                  demo_password = os.getenv("SEED_DEMO_PASSWORD", "DemoPassword123")
                  email_domain = os.getenv("SEED_EMAIL_DOMAIN", "dentari.local")

                  users = [
                      {
                          "username": os.getenv("SEED_OWNER_USERNAME", "owner"),
                          "email": f"{os.getenv('SEED_OWNER_USERNAME', 'owner')}@{email_domain}",
                          "name": os.getenv("SEED_OWNER_NAME", "Demo Owner"),
                          "role": "owner",
                      },
                      {
                          "username": os.getenv("SEED_COURIER1_USERNAME", "courier1"),
                          "email": f"{os.getenv('SEED_COURIER1_USERNAME', 'courier1')}@{email_domain}",
                          "name": os.getenv("SEED_COURIER1_NAME", "Kovács János (Motor)"),
                          "role": "courier",
                      },
                      {
                          "username": os.getenv("SEED_COURIER2_USERNAME", "courier2"),
                          "email": f"{os.getenv('SEED_COURIER2_USERNAME', 'courier2')}@{email_domain}",
                          "name": os.getenv("SEED_COURIER2_NAME", "Nagy Péter (Autó)"),
                          "role": "courier",
                      },
                  ]

                  now = datetime.utcnow()
                  for user in users:
                      session.execute(
                          text(
                              """
                              INSERT INTO users
                                  (username, email, password_hash, name, role, is_active, created_at, updated_at)
                              VALUES
                                  (:username, :email, :password_hash, :name, :role, TRUE, :created_at, :updated_at)
                              """
                          ),
                          {
                              "username": user["username"],
                              "email": user["email"],
                              "password_hash": hash_password(demo_password),
                              "name": user["name"],
                              "role": user["role"],
                              "created_at": now,
                              "updated_at": now,
                          },
                      )

                  session.commit()
                  print(f"✅ Created {len(users)} demo users")
              except Exception as exc:
                  session.rollback()
                  print(f"❌ Seeding failed: {exc}", file=sys.stderr)
                  sys.exit(1)
              finally:
                  session.close()
              PYTHON_SEED
